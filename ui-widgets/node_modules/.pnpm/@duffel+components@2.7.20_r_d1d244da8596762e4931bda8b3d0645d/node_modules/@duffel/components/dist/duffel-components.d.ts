// Generated by dts-bundle-generator v6.12.0

import { StripeError } from '@stripe/stripe-js';
import * as React from 'react';

export interface CardPaymentProps {
	duffelPaymentIntentClientToken: string;
	successfulPaymentHandler: () => void;
	errorPaymentHandler: (error: StripeError) => void;
}
export declare const CardPayment: React.FC<CardPaymentProps>;
/**
 * Airports are used to identify origins and destinations in journey slices
 * @link https://duffel.com/docs/api/airports/schema
 */
export interface Airport {
	/**
	 * The metropolitan area where the airport is located.
	 * Only present for airports which are registered with IATA as belonging to a metropolitan area.
	 */
	city?: City | null;
	/**
	 * The name of the city (or cities separated by a `/`) where the airport is located
	 */
	city_name: string;
	/**
	 * The three-character IATA code for the airport
	 */
	iata_code?: string;
	/**
	 * The ISO 3166-1 alpha-2 code for the country where the city is located
	 * @link https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2
	 * @example "GB"
	 */
	iata_country_code: string;
	/**
	 * The 3-letter IATA code for the city where the place is located.
	 * Only present for airports which are registered with IATA as belonging to a [metropolitan area](https://portal.iata.org/faq/articles/en_US/FAQ/How-do-I-create-a-new-Metropolitan-Area).
	 */
	iata_city_code?: string | null;
	/**
	 * The four-character ICAO code for the airport
	 */
	icao_code?: string;
	/**
	 * Duffel's unique identifier for the airport
	 */
	id: string;
	/**
	 * The latitude position of the airport represented in Decimal degrees with 6 decimal points with a range between -90° and 90°
	 */
	latitude: number;
	/**
	 * The longitude position of the airport represented in Decimal degrees with 6 decimal points with a range between -180° and 180°
	 */
	longitude: number;
	/**
	 * The name of the airport
	 */
	name: string;
	/**
	 * The time zone of the airport, specified by name from the [tz database](https://en.wikipedia.org/wiki/Tz_database)
	 */
	time_zone: string;
}
/**
 * Airlines are used to identify the air travel companies selling and operating flights
 * @link https://duffel.com/docs/api/airlines/schema
 */
export interface Airline {
	/**
	 * The three-character IATA code for the airline
	 */
	name: string;
	/**
	 * Duffel's unique identifier for the airline
	 */
	id: string;
	iata_code: string;
}
/**
 * Aircraft are used to describe what passengers will fly in for a given trip
 * @link https://duffel.com/docs/api/aircraft/schema
 */
export interface Aircraft {
	/**
	 * The name of the aircraft
	 */
	name: string;
	/**
	 * Duffel's unique identifier for the aircraft
	 */
	id: string;
	/**
	 * The three-character IATA code for the aircraft
	 */
	iata_code: string;
}
export interface CurrencyConversion {
	/**
	 * currency The ISO-4217 currency code to be used
	 */
	currency: string;
	/**
	 * Conversion multiple to be applied to all prices
	 */
	rate: number;
}
/**
 * Each offer represents flights you can buy from an airline at a particular price that meet your search criteria.
 * @link https://duffel.com/docs/api/offers/schema
 */
export interface Offer {
	/**
	 * The types of identity documents that may be provided for the passengers when creating an order based on this offer.
	 * Currently, the only supported type is `passport`. If this is `[]`, then you must not provide identity documents.
	 */
	allowed_passenger_identity_document_types: PassengerIdentityDocumentType[];
	/**
	 * The services that can be booked along with the offer but are not included by default, for example an additional checked bag.
	 * This field is only returned in the Get single offer endpoint.
	 * When there are no services available, or we don't support services for the airline, this list will be empty.
	 */
	available_services: OfferAvailableService[];
	/**
	 * The base price of the offer for all passengers, excluding taxes.
	 * It does not include the base amount of any service(s) that might be booked with the offer.
	 */
	base_amount: string;
	/**
	 * The currency of the `base_amount`, as an [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) currency code
	 */
	base_currency: string;
	/**
	 * The conditions associated with this offer, describing the kinds of modifications you can make post-booking and any penalties that will apply to those modifications.
	 * This information assumes the condition is applied to all of the slices and passengers associated with this offer - for information at the slice level (e.g. "what happens if I just want to change the first slice?") refer to the `slices`.
	 * If a particular kind of modification is allowed, you may not always be able to take action through the Duffel API.
	 * In some cases, you may need to contact the Duffel support team or the airline directly.
	 */
	conditions: FlightsConditions;
	/**
	 * The ISO 8601 datetime at which the offer was created
	 */
	created_at: string;
	/**
	 * The ISO 8601 datetime at which the offer will expire and no longer be usable to create an order
	 */
	expires_at: string;
	/**
	 * Duffel's unique identifier for the offer
	 */
	id: string;
	/**
	 * Whether the offer request was created in live mode.
	 * This field will be set to `true` if the offer request was created in live mode, or `false` if it was created in test mode.
	 */
	live_mode: boolean;
	/**
	 * The airline which provided the offer
	 */
	owner: Airline;
	/**
	 * Whether identity documents must be provided for each of the passengers when creating an order based on this offer.
	 * If this is `true`, you must provide an identity document for every passenger.
	 */
	passenger_identity_documents_required: boolean;
	/**
	 * The passengers included in the offer
	 */
	passengers: OfferPassenger[];
	/**
	 * The payment requirements for this offer
	 */
	payment_requirements: PaymentRequirements;
	/**
	 * The slices that make up this offer. Each slice will include one or more segments,
	 * the specific flights that the airline is offering to take the passengers from the slice's `origin` to its `destination`.
	 */
	slices: OfferSlice[];
	/**
	 * The amount of tax payable on the offer for all passengers
	 */
	tax_amount: string | null;
	/**
	 * The currency of the `tax_amount`, as an [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) currency code
	 */
	tax_currency: string | null;
	/**
	 * The total price of the offer for all passengers, including taxes.
	 * It does not include the total price of any service(s) that might be booked with the offer.
	 */
	total_amount: string;
	/**
	 * An estimate of the total carbon dioxide (CO₂) emissions when
	 * all of the passengers fly this offer's itinerary, measured in kilograms
	 */
	total_emissions_kg: string;
	/**
	 * The currency of the `total_amount`, as an [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) currency code
	 */
	total_currency: string;
	/**
	 * The ISO 8601 datetime at which the offer was last updated
	 */
	updated_at: string;
}
export interface OfferAvailableServiceBaggageMetadata {
	/**
	 * The maximum weight that the baggage can have in kilograms
	 */
	maximum_weight_kg?: number | null;
	/**
	 * The maximum height that the baggage can have in centimetres
	 */
	maximum_height_cm?: number | null;
	/**
	 * The maximum length that the baggage can have in centimetres
	 */
	maximum_length_cm?: number | null;
	/**
	 * The maximum depth that the baggage can have in centimetres
	 */
	maximum_depth_cm?: number | null;
	/**
	 * The type of the baggage
	 */
	type: BaggageType;
}
export interface PaymentRequirements {
	/**
	 *  The ISO 8601 datetime by which you must pay for this order.
	 * At this time, if still unpaid, the reserved space on the flight(s)
	 * will be released and you will have to create a new order.
	 * This will be null only for orders where `awaiting_payment` is `false`.
	 */
	payment_required_by?: string | null;
	/**
	 *  The ISO 8601 datetime at which the price associated
	 * with the order will no longer be guaranteed by the airline
	 * and the order will need to be repriced before payment.
	 * This can be null when there is no price guarantee.
	 */
	price_guarantee_expires_at?: string | null;
	/**
	 * Whether immediate payment is required or not
	 */
	requires_instant_payment: boolean;
}
export interface OfferAvailableServiceMetadataMap {
	baggage: OfferAvailableServiceBaggageMetadata;
}
export declare type OfferAvailableServiceType = keyof OfferAvailableServiceMetadataMap;
export interface OfferAvailableService<T_ServiceType extends OfferAvailableServiceType = "baggage"> {
	/**
	 * Duffel's unique identifier for the service
	 */
	id: string;
	/**
	 * The maximum quantity of this service that can be booked with an order
	 */
	maximum_quantity: number;
	/**
	 * An object containing metadata about the service, like the maximum weight and dimensions of the baggage.
	 */
	metadata: OfferAvailableServiceMetadataMap[T_ServiceType];
	/**
	 * The list of passenger `id`s the service applies to.
	 * If you add this service to an order it will apply to all the passengers in this list.
	 * For services where the type is `baggage`, this list will include only a single passenger.
	 */
	passenger_ids: string[];
	/**
	 * The list of segment ids the service applies to.
	 * If you add this service to an order it will apply to all the segments in this list.
	 * For services where the type is baggage, depending on the airline,
	 * this list includes all the segments of all slices or all the segments of a single slice.
	 */
	segment_ids: string[];
	/**
	 * The total price of the service for all passengers and segments it applies to, including taxes
	 */
	total_amount: string;
	/**
	 * The currency of the `total_amount`, as an ISO 4217 currency code
	 */
	total_currency: string;
	/**
	 * The type of the service.
	 * For now we only return services of type baggage but we will return other types in the future.
	 * We won't consider adding new service types a break change.
	 */
	type: T_ServiceType;
}
export interface OfferPassenger {
	/**
	 * The age of the passenger on the departure_date of the final slice.
	 */
	age?: number;
	/**
	 * The type of the passenger.
	 */
	type?: "adult";
	/**
	 * The identifier for the passenger, unique within this Offer Request and across all Offer Requests.
	 * This ID will be generated by Duffel unless you had optionally provided one.
	 * Optionally providing one has been deprecated.
	 */
	id: string;
}
export interface OfferSlice {
	/**
	 * The type of the destination
	 */
	destination_type: PlaceType;
	/**
	 * The city or airport where this slice ends
	 */
	destination: Place;
	/**
	 * The type of the origin
	 */
	origin_type: PlaceType;
	/**
	 * The city or airport where this slice begins
	 */
	origin: Place;
	/**
	 * The duration of the slice, represented as a ISO 8601 duration
	 */
	duration: string | null;
	/**
	 * The name of the fare brand associated with this slice.
	 * A fare brand specifies the travel conditions you get on your slice made available
	 * by the airline. e.g. a British Airways Economy Basic fare will only include a hand baggage allowance.
	 * It is worth noting that the fare brand names are defined by the airlines themselves and therefore they
	 * are subject to change without any prior notice. We're in the process of adding support for fare_brand_name across
	 * all our airlines, so for now, this field may be null in some offers.
	 * This will become a non-nullable attribute in the near future.
	 */
	fare_brand_name: string | null;
	/**
	 * Duffel's unique identifier for the slice. It identifies the slice of an offer (i.e. the same slice across offers will have different `id`s
	 */
	id: string;
	/**
	 * The segments - that is, specific flights - that the airline is offering to get the passengers from the `origin` to the `destination`
	 */
	segments: OfferSliceSegment[];
	/**
	 * The conditions associated with this slice, describing the kinds of modifications you can make post-booking and any penalties that will apply to those modifications.
	 * This condition is applied only to this slice and to all the passengers associated with this offer - for information at the offer level (e.g. "what happens if I want to change all the slices?") refer to the conditions at the top level.
	 * If a particular kind of modification is allowed, you may not always be able to take action through the Duffel API.
	 * In some cases, you may need to contact the Duffel support team or the airline directly.
	 */
	conditions: FlightsConditions;
}
export interface OfferSliceSegment {
	/**
	 * The aircraft that the operating carrier will use to operate this segment
	 */
	aircraft: Aircraft;
	/**
	 * The ISO 8601 datetime at which the segment is scheduled to arrive
	 */
	arriving_at: string;
	/**
	 * The terminal at the destination airport where the segment is scheduled to arrive
	 */
	destination_terminal: string | null;
	/**
	 * The ISO 8601 datetime at which the segment is scheduled to depart
	 */
	departing_at: string;
	/**
	 * The terminal at the origin airport from which the segment is scheduled to depart
	 */
	origin_terminal: string | null;
	/**
	 * The airport at which the segment is scheduled to arrive
	 */
	destination: Airport;
	/**
	 * The distance of the segment in kilometres
	 */
	distance: string | null;
	/**
	 * The duration of the segment, represented as a ISO 8601 duration
	 */
	duration: string | null;
	/**
	 * Duffel's unique identifier for the segment. It identifies the segment of an offer (i.e. the same segment across offers will have different `id`s
	 */
	id: string;
	/**
	 * The airline selling the tickets for this segment.
	 * This may differ from the `operating_carrier` in the case of a "codeshare", where one airline sells flights operated by another airline.
	 */
	marketing_carrier: Airline;
	/**
	 * The flight number assigned by the marketing carrier
	 */
	marketing_carrier_flight_number: string;
	/**
	 * The airport from which the flight is scheduled to depart
	 */
	origin: Airport;
	/**
	 * The airline actually operating this segment.
	 * This may differ from the marketing_carrier in the case of a "codeshare", where one airline sells flights operated by another airline.
	 */
	operating_carrier: Airline;
	/**
	 * The flight number assigned by the operating carrier
	 */
	operating_carrier_flight_number: string;
	/**
	 * Additional segment-specific information about the passengers included in the offer (e.g. their baggage allowance and the cabin class they will be travelling in)
	 */
	passengers: OfferSliceSegmentPassenger[];
}
export interface OfferSliceSegmentPassenger {
	/**
	 * The baggage allowances for the passenger on this segment included in the offer.
	 * Some airlines may allow additional baggage to be booked as a service - see the offer's available_services.
	 */
	baggages: OfferSliceSegmentPassengerBaggage[];
	/**
	 * The cabin class that the passenger will travel in on this segment
	 */
	cabin_class: CabinClass;
	/**
	 * The name that the marketing carrier uses to market this cabin class
	 */
	cabin_class_marketing_name: string;
	/**
	 * The identifier for the passenger.
	 * You may have specified this ID yourself when creating the offer request, or otherwise, Duffel will have generated its own random ID.
	 */
	passenger_id: string;
	/**
	 * The airline's alphanumeric code for the fare that the passenger is using to travel. Where this is `null`, it means that either the
	 * fare basis code is not available or the airline does not use fare basis codes.
	 */
	fare_basis_code: string;
}
export declare type BaggageType = "carry_on" | "checked";
export interface OfferSliceSegmentPassengerBaggage {
	/**
	 * The type of the baggage allowance
	 */
	type: BaggageType;
	/**
	 * The number of this type of bag allowed on the segment. Note that this can currently be 0 in some cases.
	 */
	quantity: number;
}
/**
 * The metropolitan area where the airport is located.
 * Only present for airports which are registered with IATA as belonging to a metropolitan area.
 * @link https://portal.iata.org/faq/articles/en_US/FAQ/How-do-I-create-a-new-Metropolitan-Area
 */
export interface City {
	/**
	 * The type of the place
	 */
	type?: "city";
	/**
	 * The three-character IATA code for the city
	 * @example "LON"
	 */
	iata_code: string;
	/**
	 * The ISO 3166-1 alpha-2 code for the country where the city is located
	 * @link https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2
	 * @example "GB"
	 */
	iata_country_code: string;
	/**
	 * Duffel's unique identifier for the city
	 * @example "cit_lon_gb"
	 */
	id: string;
	/**
	 * The name of the city
	 * @example "London"
	 */
	name: string;
	/**
	 * The time zone of the airport, specified by name from the [tz database](https://en.wikipedia.org/wiki/Tz_database)
	 */
	time_zone?: string | null;
	/**
	 * The longitude position of the airport represented in [Decimal degrees](https://en.wikipedia.org/wiki/Decimal_degrees) with 6 decimal points with a range between -180° and 180°
	 */
	longitude?: number | null;
	/**
	 * The latitude position of the airport represented in [Decimal degrees](https://en.wikipedia.org/wiki/Decimal_degrees) with 6 decimal points with a range between -90° and 90°
	 */
	latitude?: number | null;
	/**
	 * The 3-letter IATA code for the city where the place is located.
	 * Only present for airports which are registered with IATA as belonging to a [metropolitan area](https://portal.iata.org/faq/articles/en_US/FAQ/How-do-I-create-a-new-Metropolitan-Area).
	 */
	iata_city_code?: string | null;
	/**
	 * The name of the city (or cities separated by a `/`) where the airport is located
	 */
	city_name?: string | null;
}
/**
 * The cabin class that the passenger will travel in on this segment
 */
export declare type CabinClass = "first" | "business" | "premium_economy" | "economy";
/**
 * The type of the passenger
 */
export declare type DuffelPassengerType = "adult" | "child" | "infant_without_seat";
/**
 * The passenger's title
 */
export declare type DuffelPassengerTitle = "mr" | "ms" | "mrs" | "MR" | "MS" | "MRS";
/**
 * The passenger's gender
 */
export declare type DuffelPassengerGender = "m" | "f";
/**
 * The type of the identity document. Currently, the only supported type is passport.
 * This must be one of the `allowed_passenger_identity_document_types` on the offer.
 */
export declare type PassengerIdentityDocumentType = "passport";
/**
 * The type of the origin or destination
 */
export declare type PlaceType = "airport" | "city";
export declare type Place = (Airport & {
	type?: "airport";
	airports?: Airport[] | null;
}) | (City & {
	type?: "city";
});
/**
 * The conditions associated with this offer, describing the kinds of modifications you can make post-booking and any penalties that will apply to those modifications.
 * This information assumes the condition is applied to all of the slices and passengers associated with this offer - for information at the slice level (e.g. "what happens if I just want to change the first slice?") refer to the slices.
 * If a particular kind of modification is allowed, you may not always be able to take action through the Duffel API.
 * In some cases, you may need to contact the Duffel support team or the airline directly.
 */
export declare type FlightsConditions = {
	/**
	 * Whether the whole order or offer can be refunded before the departure of the first slice.
	 * If all of the slices on the order or offer can be refunded then the `allowed` property will be `true` and information will be provided about any penalties.
	 * If any of the slices on the order or offer can't be refunded then the `allowed` property will be `false`.
	 * If the airline hasn't provided any information about whether this order or offer can be refunded then this property will be `null`.
	 */
	refund_before_departure?: {
		/**
		 * The currency of the `penalty_amount` as an [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) currency code.
		 * This will be in a currency determined by the airline, which is not necessarily the same as the currency of the order or offer.
		 * If this is `null` then `penalty_amount` will also be `null`.
		 * @example "GBP"
		 */
		penalty_currency?: string;
		/**
		 * If the modification is `allowed` then this is the amount payable to apply the modification to all passengers.
		 * If there is no penalty, the value will be zero. If the modification isn't `allowed` or the penalty is not known then this field will be `null`.
		 * If this is `null` then the `penalty_currency` will also be null.
		 * @example "100.00"
		 */
		penalty_amount?: string;
		/**
		 * Whether this kind of modification is allowed post-booking
		 *
		 * @example "true"
		 */
		allowed: boolean;
	} | null;
	/**
	 * Whether the whole order or offer can be changed before the departure of the first slice.
	 * If all of the slices on the order or offer can be changed then the `allowed` property will be `true`.
	 * Refer to the `slices` for information about change penalties.
	 * If any of the slices on the order or offer can't be changed then the `allowed` property will be `false`.
	 * In this case you should refer to the slices conditions to determine if any part of the order or offer is changeable.
	 * If the airline hasn't provided any information about whether this order or offer can be changed then this property will be `null`.
	 */
	change_before_departure?: {
		/**
		 * The currency of the `penalty_amount` as an [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) currency code.
		 * This will be in a currency determined by the airline, which is not necessarily the same as the currency of the order or offer.
		 * If this is `null` then `penalty_amount` will also be `null`.
		 * @example "GBP"
		 */
		penalty_currency: string;
		/**
		 * If the modification is `allowed` then this is the amount payable to apply the modification to all passengers.
		 * If there is no penalty, the value will be zero. If the modification isn't `allowed` or the penalty is not known then this field will be `null`.
		 * If this is `null` then the `penalty_currency` will also be null.
		 * @example "100.00"
		 */
		penalty_amount?: string;
		/**
		 * Whether this kind of modification is allowed post-booking
		 *
		 * @example "true"
		 */
		allowed: boolean;
	} | null;
};
/**
 * The type of payment you want to apply to the order.
 * If you are an IATA agent with your own agreements with airlines, in some cases, you can pay using ARC/BSP cash by specifying `arc_bsp_cash`. Otherwise, you must pay using your Duffel account's balance by specifying `balance`.
 * In test mode, your balance is unlimited. If you're not sure which of these options applies to you, get in touch with the Duffel support team at [help@duffel.com](mailto:help@duffel.com).
 */
export declare type PaymentType = "arc_bsp_cash" | "balance";
export interface LayoutSelectionPassenger {
	id: string;
	name?: string | null;
}
/**
 * Metadata for component usage tracking
 */
export interface ComponentUsageMetadata {
	duffel_component_used: "additional_baggage" | "additional_baggage_selection" | "seat_selection";
	duffel_components_version: string;
}
/**
 * Seat maps are used to build a rich experience for your customers so they can select a seat as part of an order.
 * A seat map includes the data for rendering seats in the relevant cabins, along with their total cost and other information such as disclosures.
 * @link https://duffel.com/docs/api/seat-maps/schema
 */
export interface SeatMap {
	/**
	 * Duffel's unique identifier for the seat map
	 */
	id: string;
	/**
	 * Duffel's unique identifier for the slice. It identifies the slice of an offer (i.e. the same slice across offers will have different ids.)
	 */
	slice_id: string;
	/**
	 * Duffel's unique identifier for the segment. It identifies the segment of an offer (i.e. the same segment across offers will have different ids).
	 */
	segment_id: string;
	/**
	 * The list of cabins in this seat map.
	 * Cabins are ordered by deck from lowest to highest, and then within each deck from the front to back of the aircraft.
	 */
	cabins: SeatMapCabin[];
}
export interface SeatMapCabin {
	/**
	 * Level 0 is the main deck and level 1 is the upper deck above that, which is found on some large aircraft.
	 */
	deck: number;
	/**
	 * The cabin class that the passenger will travel in on this segment
	 */
	cabin_class: string;
	/**
	 * Where the wings of the aircraft are in relation to rows in the cabin.
	 * The numbers correspond to the indices of the first and the last row which are overwing. You can use this to draw a visual representation of the wings to help users get a better idea of what they will see outside their window.
	 * The indices are 0 th-based and are for all rows, not just those that have seats.
	 * This is null when no rows of the cabin are overwing.
	 */
	wings: {
		/**
		 * The index of the first row which is overwing, starting from the front of the aircraft.
		 */
		first_row_index: number;
		/**
		 * The index of the last row which is overwing, starting from the front of the aircraft.
		 */
		last_row_index: number;
	} | null;
	/**
	 * The number of aisles in this cabin.
	 * If this is set to 1, each row of the cabin is split into two sections. If this is set to 2, each row of the cabin is split into three section.
	 */
	aisles: number;
	/**
	 * A list of rows in this cabin.
	 * Row sections are broken up by aisles. Rows are ordered from front to back of the aircraft.
	 */
	rows: SeatMapCabinRow[];
}
export interface SeatMapCabinRow {
	/**
	 * A list of sections.
	 * Each row is divided into sections by one or more aisles.
	 */
	sections: SeatMapCabinRowSection[];
}
export interface SeatMapCabinRowSection {
	/**
	 * The elements that make up this section.
	 */
	elements: SeatMapCabinRowSectionElement[];
}
/**
 * A seat for a passenger. If the available_services list is empty (which will be represented as an empty list : []), the seat is unavailable.
 * For display, all seats should be displayed with the same static width.
 */
export interface SeatMapCabinRowSectionElementSeat {
	/**
	 * The type of this element.
	 */
	type: "seat";
	/**
	 * The designator used to uniquely identify the seat, usually made up of a row number and a column letter
	 */
	designator: string;
	/**
	 * A name which describes the type of seat, which you can display in your user interface to help customers to understand its features
	 */
	name?: string;
	/**
	 * Each disclosure is text, in English, provided by the airline that describes the terms and conditions of this seat. We recommend showing this in your user interface to make sure that customers understand any restrictions and limitations.
	 */
	disclosures: string[];
	/**
	 * Seats are considered a special kind of service. There will be at most one service per seat per passenger. A seat can only be booked for one passenger. If a seat has no available services (which will be represented as an empty list : []) then it's unavailable.
	 */
	available_services: SeatMapCabinRowSectionAvailableService[];
}
export interface SeatMapCabinRowSectionAvailableService {
	/**
	 * Duffel's unique identifier for the service
	 */
	id: string;
	/**
	 * The passenger that this seat is for
	 */
	passenger_id: string;
	/**
	 * The total price of the seat, including taxes
	 */
	total_amount: string;
	/**
	 * The currency of the total_amount, as an ISO 4217 currency code
	 */
	total_currency: string;
	/**
	 * Metadata for component usage tracking
	 */
	metadata?: ComponentUsageMetadata;
}
/**
 * A bassinet is a child's cradle. This element will be aligned with the corresponding seat in the following row.
 * For display, this element should have the same width as a seat for proper alignment.
 */
export interface SeatMapCabinRowSectionElementBassinet {
	/**
	 * The type of this element.
	 */
	type: "bassinet";
}
/**
 * An empty space used for padding in some non-standard seat arrangements.
 * For display, this element should have the same dimensions as a seat for proper alignment.
 */
export interface SeatMapCabinRowSectionElementEmpty {
	/**
	 * The type of this element.
	 */
	type: "empty";
}
/**
 * An exit row represents the extra wide legroom used to reach aircraft exits. There is one exit_row element per row section.
 * Exit row elements only occur in their own row, so they can be displayed as one element across the whole row. Displaying an exit row element filling all available space in its section or using the same width as the seat is also reasonable.
 */
export interface SeatMapCabinRowSectionElementExitRow {
	/**
	 * The type of this element.
	 */
	type: "exit_row";
}
/**
 * A lavatory for use by passengers.
 * For display, this element should ideally fill or shrink to available space in a row section. Displaying it with the same width as seat is also reasonable.
 */
export interface SeatMapCabinRowSectionElementLavatory {
	/**
	 * The type of this element.
	 */
	type: "lavatory";
}
/**
 * A galley is the compartment where food is cooked or prepared. These are conventionally marked with a teacup symbol.
 * For display, this element should ideally fill or shrink to available space in a row section. Displaying it with the same width as seat is also reasonable.
 */
export interface SeatMapCabinRowSectionElementGalley {
	/**
	 * The type of this element.
	 */
	type: "galley";
}
/**
 * A closet used for storage. These are conventionally marked with a clothes hanger symbol.
 * For display, this element should ideally fill or shrink to available space in a row section. Displaying it with the same width as seat is also reasonable.
 */
export interface SeatMapCabinRowSectionElementCloset {
	/**
	 * The type of this element.
	 */
	type: "closet";
}
/**
 * A set of stairs to another deck.
 * For display, this element should ideally fill or shrink to available space in a row section. Displaying it with the same width as seat is also reasonable.
 */
export interface SeatMapCabinRowSectionElementStairs {
	/**
	 * The type of this element.
	 */
	type: "stairs";
}
export declare type SeatMapCabinRowSectionElement = SeatMapCabinRowSectionElementSeat | SeatMapCabinRowSectionElementBassinet | SeatMapCabinRowSectionElementEmpty | SeatMapCabinRowSectionElementExitRow | SeatMapCabinRowSectionElementLavatory | SeatMapCabinRowSectionElementGalley | SeatMapCabinRowSectionElementCloset | SeatMapCabinRowSectionElementStairs;
export interface SeatSelectionPassenger {
	id: string;
	name?: string | null;
}
export declare type SeatSelectionContextInterface = {
	[segmentId: string]: SeatSelectionForSegment;
};
export declare type SeatSelectionForSegment = {
	[passengerId: string]: SeatInformation | null;
};
export declare type SeatInformation = {
	designator: string;
	service: SeatMapCabinRowSectionAvailableService;
};
export interface SeatSelectionProps {
	/**
	 * The offer we are booking seats for.
	 */
	offer: Offer;
	/**
	 * List of available seat maps
	 */
	seatMaps: SeatMap[];
	/**
	 * List of all passengers that can be assigned seats
	 */
	passengers: SeatSelectionPassenger[];
	/**
	 * What to do when the user presses the Confirm button
	 */
	onSubmit: (seats: SeatSelectionContextInterface) => void;
	/**
	 * Already selected seats to initialize the map with
	 */
	initialSeatSelection?: SeatSelectionContextInterface;
	/**
	 * The segment ID to select upon initialization
	 */
	initialSegmentId?: string;
	/**
	 * Optional currency conversion to enable prices to be shown in an alternative currency
	 */
	currencyConversion?: CurrencyConversion;
}
export declare const SeatSelection: React.FC<SeatSelectionProps>;
export declare type Baggage = {
	id: string;
	quantity: number;
	metadata?: ComponentUsageMetadata;
};
export interface AdditionalBaggageProps {
	/**
	 * List of available services in the offer
	 */
	availableServices: OfferAvailableService[];
	/**
	 * List of current additional baggages
	 */
	additionalBaggages: Baggage[];
	/**
	 * onChange handler responsible to get the services object to send to the API
	 */
	onChange: (updatedBaggages: Baggage[], lastBaggageUpdated: Baggage) => void;
	/**
	 * Optional currency conversion to enable prices to be shown in an alternative currency
	 */
	currencyConversion?: CurrencyConversion;
}
export declare const AdditionalBaggage: React.FC<AdditionalBaggageProps>;
export declare type OrderAvailableService = OfferAvailableService;
export interface TravelAgentTicket {
	id: string;
	externalTicketId: string;
}
export declare type EmptyObject = Record<string, unknown>;
export declare type OrderAvailableAction = "cancel" | "change" | "update";
export declare type AvailableActionType = "accept" | "cancel" | "change" | "update";
export declare type ActionTakenType = "accepted" | "cancelled" | "changed" | null;
export declare type OfferCondition = OfferConditionModificationAllowed | OfferConditionNoModification;
export interface LoyaltyProgrammeAccount {
	/**
	 * The passenger's account number for this Loyalty Programme Account
	 */
	account_number: string;
	/**
	 * The IATA code for the airline that this Loyalty Programme Account belongs to
	 */
	airline_iata_code: string;
}
export interface OrderService {
	/**
	 * The `id` of the service from the offer's `available_services` that you want to book
	 */
	id: string;
	/**
	 * The quantity of the service to book
	 */
	quantity: number;
}
export interface OrderPassenger {
	born_on: string;
	family_name: string;
	gender: DuffelPassengerGender;
	given_name: string;
	id: string;
	infant_passenger_id?: string | null;
	loyalty_programme_accounts?: LoyaltyProgrammeAccount[];
	title: DuffelPassengerTitle;
	type: DuffelPassengerType;
}
export declare type OrderDocumentsType = "electronic_ticket" | "electronic_miscellaneous_document_associated" | "electronic_miscellaneous_document_standalone";
export declare type OrderDocuments = OrderDocument[];
export interface OrderDocument {
	/**
	 * The list of passenger ids the document applies to.
	 *
	 * @example
	 * ["pas_00009hj8USM7Ncg31cBCLL"]
	 */
	passenger_ids: string[];
	/**
	 * The type of document.
	 */
	type: OrderDocumentsType;
	/**
	 * The identifier for the document, in the case of electronic tickets this
	 * string represents the payment or the entitlement to fly.
	 *
	 * @example
	 * "1252106312810"
	 */
	unique_identifier: string;
}
export interface OrderPaymentStatus {
	/**
	 * Whether a payment has been made, or the airline is waiting for a payment to be made
	 */
	awaiting_payment: boolean;
	/**
	 *  The ISO 8601 datetime by which you must pay for this order.
	 * At this time, if still unpaid, the reserved space on the flight(s)
	 * will be released and you will have to create a new order.
	 * This will be null only for orders where `awaiting_payment` is `false`.
	 * Payment Required by means it will hold space
	 */
	payment_required_by?: string | null;
	/**
	 *  The ISO 8601 datetime at which the price associated
	 * with the order will no longer be guaranteed by the airline
	 * and the order will need to be repriced before payment.
	 * This can be null when there is no price guarantee.
	 * Price Guarantee means it will hold price
	 */
	price_guarantee_expires_at?: string | null;
	/**
	 * TODO: this is undocumented. Check back on https://duffel.com/docs/api/orders/schema
	 */
	unpaid_guarantees?: any;
	/**
	 * TODO: this is undocumented. Check back on https://duffel.com/docs/api/orders/schema
	 */
	payBy?: string | null;
	/**
	 *  The ISO 8601 datetime at which the Order was paid for, if at all
	 */
	paid_at: string | null;
}
export interface OrderChangeRequestOfferSlices {
	/**
	 * The slices to be added
	 */
	add: Array<OrderSlice>;
	/**
	 * The slices to be removed
	 */
	remove: Array<OrderSlice>;
}
export interface OrderChangeRequestOffer {
	/**
	 * The available payment types to complete the order change.
	 *
	 * @todo
	 * Add this field to the API docs.
	 */
	available_payment_types?: PaymentType[] | null;
	/**
	 * The amount that will be charged or returned to the original payment
	 * method if refunded, determined according to the fare conditions. This
	 * may be negative to reflect a refund.
	 *
	 * @example
	 * "90.80"
	 */
	change_total_amount: string;
	/**
	 * The currency of the `change_total_amount`, as an ISO 4217 currency
	 * code. It will match your organisation's billing currency unless you’re
	 * using Duffel as an accredited IATA agent, in which case it will be in
	 * the currency provided by the airline (which will usually be based on
	 * the country where your IATA agency is registered).
	 *
	 * @example
	 * "GBP"
	 */
	change_total_currency: string;
	/**
	 * The ISO 8601 datetime at which the offer was created.
	 *
	 * @example
	 * "2020-01-17T10:12:14.545Z"
	 */
	created_at: string;
	/**
	 * The ISO 8601 datetime at which the offer will expire and no longer be
	 * usable to create an order.
	 *
	 * @example
	 * "2020-01-17T10:42:14.545Z"
	 *
	 */
	expires_at: string;
	/**
	 * Duffel's unique identifier for the order change offer.
	 *
	 * @example
	 * "oco_0000A3vUda8dKRtUSQPSXw"
	 */
	id: string;
	/**
	 * Whether the order change offer was created in live mode. This field
	 * will be set to `true` if the order change offer was created in live
	 * mode, or `false if it was created in test mode.
	 *
	 * @example
	 * false
	 */
	live_mode: boolean;
	/**
	 * The price of this offer if it was newly purchased.
	 *
	 * @example
	 * "35.50"
	 */
	new_total_amount: string;
	/**
	 * The currency of the `new_total_amount`, as an ISO 4217 currency code.
	 * It will match your organisation's billing currency unless you’re using
	 * Duffel as an accredited IATA agent, in which case it will be in the
	 * currency provided by the airline (which will usually be based on the
	 * country where your IATA agency is registered).
	 *
	 * @example
	 * "GBP"
	 */
	new_total_currency: string;
	/**
	 * The ID for an order change if one has already been created from this
	 * order change offer.
	 *
	 * @example
	 * "oce_0000A4QasEUIjJ6jHKfhHU"
	 */
	order_change_id: string | null;
	/**
	 * The penalty price imposed by the airline for making this change.
	 *
	 * @example
	 * "10.50"
	 */
	penalty_total_amount: string | null;
	/**
	 * The currency of the `penalty_total_amount`, as an ISO 4217 currency
	 * code. It will match your organisation's billing currency unless you’re
	 * using Duffel as an accredited IATA agent, in which case it will be in
	 * the currency provided by the airline (which will usually be based on
	 * the country where your IATA agency is registered).
	 *
	 * @example
	 * "GBP"
	 */
	penalty_total_currency: string | null;
	/**
	 * Where the refund, once confirmed, will be sent. card is currently a
	 * restricted feature. `awaiting_payment` is for pay later orders where no
	 * payment has been made yet.
	 *
	 * @todo
	 * Align this field with the API docs.
	 */
	refund_to: "voucher" | "original_form_of_payment" | null;
	/**
	 * The slices within an order change that are being added to and/or
	 * removed from the order.
	 */
	slices: OrderChangeRequestOfferSlices;
	/**
	 * The ISO 8601 datetime at which the offer was last updated.
	 *
	 * @example
	 * "2020-01-17T10:12:14.545Z"
	 */
	updated_at: string;
}
export interface OrderChange extends Omit<OrderChangeRequestOffer, "orderChangeId"> {
	/**
	 * The ISO 8601 datetime that indicates when the order change was
	 * confirmed.
	 *
	 * @example
	 * "2020-01-17T11:51:43.114803Z"
	 */
	confirmed_at: string | null;
	/**
	 * Duffel's unique identifier for the order change.
	 *
	 * @example
	 * "oce_0000A4QasEUIjJ6jHKfhHU"
	 */
	id: string;
}
export declare type OrderChanges = OrderChange[];
export interface OfferConditionModificationAllowed {
	/**
	 * Allow the modification to the order
	 */
	allowed: true;
	/**
	 * The penalty of the modification
	 */
	penalty_amount: number | null;
	/**
	 * The penalty currency of the modification
	 */
	penalty_currency: string | null;
}
export interface OfferConditionNoModification {
	/**
	 * No modification to the order is allowed
	 */
	allowed: false;
	/**
	 * When the modification to the order is not allowed, both penalty amount and currency should be null
	 */
	penalty_amount: null;
	penalty_currency: null;
}
export interface OrderSegmentPassengerBaggage {
	quantity: number;
	type: string;
}
export interface OrderSegmentPassenger {
	baggages: OrderSegmentPassengerBaggage[];
	cabin_class: CabinClass;
	cabin_class_marketing_name: string;
	passenger_id?: string;
	/**
	 * TODO: undocumented. Come back to add the correct type.
	 */
	seat?: null;
}
export interface OrderSliceSegment {
	/**
	 * The aircraft that the operating carrier will use to operate this
	 * segment.
	 */
	aircraft: Aircraft;
	/**
	 * The ISO 8601 datetime at which the segment is scheduled to arrive. You
	 * should use the `arrivingAt` attribute instead of this attribute, as this
	 * will be removed in the next API version.
	 *
	 * @deprecated
	 * @example
	 * "2020-06-13T16:38:02"
	 */
	arrival_datetime: string;
	/**
	 * The terminal at the destination airport where the segment is scheduled
	 * to arrive. You should use the `destinationTerminal` attribute instead
	 * of this attribute, as this will be removed in the next API version.
	 *
	 * @deprecated
	 * @example
	 * "5"
	 */
	arrival_terminal: string | null;
	/**
	 * The ISO 8601 datetime at which the segment is scheduled to arrive, in
	 * the destination airport timezone (see `destination.timezone`)
	 *
	 * @example
	 * "2020-06-13T16:38:02"
	 */
	arriving_at: string;
	/**
	 * The ISO 8601 datetime at which the segment is scheduled to depart, in
	 * the origin airport timezone (see `origin.timezone`)
	 *
	 * @example
	 * "2020-06-13T16:38:02"
	 */
	departing_at: string;
	/**
	 * The ISO 8601 datetime at which the segment is scheduled to depart. You
	 * should use the `departingAt` attribute instead of this attribute, as
	 * this will be removed in the next API version.
	 *
	 * @deprecated
	 * @example
	 * "2020-06-13T16:38:02"
	 */
	departure_datetime: string;
	/**
	 * The terminal at the `origin` airport from which the segment is
	 * scheduled to depart. You should use the `origin_terminal` attribute
	 * instead of this attribute, as this will be removed in the next API
	 * version.
	 *
	 * @deprecated
	 * @example
	 * "B"
	 */
	departure_terminal: string | null;
	destination: Airport;
	/**
	 * The terminal at the destination airport where the segment is scheduled
	 * to arrive.
	 *
	 * @example
	 * "5"
	 */
	destination_terminal: string;
	/**
	 * The distance of the segment in kilometres.
	 *
	 * @example
	 * "424.2"
	 */
	distance: string;
	/**
	 * The duration of the segment, represented as a ISO 8601 duration.
	 *
	 * @example
	 * "PT02H26M"
	 */
	duration: string;
	/**
	 * Duffel's unique identifier for the segment. It identifies the segment
	 * of an order (i.e. the same segment across orders will have different
	 * ids.
	 *
	 * @example
	 * "seg_00009htYpSCXrwaB9Dn456"
	 */
	id: string;
	/**
	 * The airline selling the tickets for this segment. This may differ from
	 * the `operatingCarrier` in the case of a "codeshare", where one airline
	 * sells flights operated by another airline.
	 */
	marketing_carrier: Airline;
	/**
	 * The flight number assigned by the marketing carrier.
	 *
	 * @example
	 * "1234"
	 */
	marketing_carrier_flight_number: string;
	/**
	 * The airline actually operating this segment. This may differ from the
	 * `marketingCarrier` in the case of a "codeshare", where one airline
	 * sells flights operated by another airline.
	 */
	operating_carrier: Airline;
	/**
	 * The flight number assigned by the operating carrier. This may not be
	 * present, in which case you should display the `marketingCarrier`'s
	 * information and the `marketingCarrierFlightNumber`, and simply state
	 * the name of the `operatingCarrier.
	 *
	 * @example
	 * "4321"
	 */
	operating_carrier_flight_number: string;
	/**
	 * The airport from which the flight is scheduled to depart.
	 */
	origin: Airport;
	/**
	 * The terminal at the origin airport from which the segment is scheduled
	 * to depart.
	 *
	 * @example
	 * "B"
	 */
	origin_terminal: string;
	/**
	 * Additional segment-specific information about the passengers included
	 * in the offer (e.g. their baggage allowance and the cabin class they
	 * will be travelling in)
	 */
	passengers: OrderSegmentPassenger[];
}
export interface OrderSlice {
	id?: string;
	origin: Airport;
	origin_type?: PlaceType | null;
	destination_type?: PlaceType | null;
	destination: Airport;
	segments: OrderSliceSegment[];
	duration?: string | null;
	conditions: {
		change_before_departure: OfferCondition | null;
	};
}
export interface AirlineInitiatedChange {
	/**
	 * Duffel's unique identifier for the airline-initiated change
	 */
	id: string;
	/**
	 * Duffel's unique identifier for the order
	 */
	order_id: string;
	/**
	 * List of updated slices and segments following the change
	 */
	added: OrderSlice[];
	/**
	 * List of slices and segments as they were before the change
	 */
	removed: OrderSlice[];
	/**
	 * The action taken in response to this airline-initiated change
	 */
	action_taken: ActionTakenType;
	/**
	 * The ISO 8601 datetime at which an action was taken
	 */
	action_taken_at: string | null;
	/**
	 * The available actions you can take on this Airline-Initiated Change through our API.
	 * 'update' means that you can use the update endpoint for an Airline-Initiated Change.
	 */
	available_actions: AvailableActionType[];
	/**
	 * The ISO 8601 datetime at which the Payment Intent was created
	 */
	created_at: string;
	/**
	 * The ISO 8601 datetime at which the airline-initiated change was last updated
	 */
	updated_at: string;
	/**
	 * The associated Travel Agent Ticket, if any, for this Airline-Initiated Change.
	 * This value will be present for Airline-Initiated changes that take some time to be processed.
	 */
	travel_agent_ticket: TravelAgentTicket | EmptyObject | null;
}
export declare type AirlineInitiatedChanges = AirlineInitiatedChange[];
export interface Order {
	/**
	 * The airline-initiated changes for this order.
	 */
	airline_initiated_changes: AirlineInitiatedChanges;
	/**
	 * The available actions you can take on this Order through our API.
	 */
	available_actions: OrderAvailableAction[];
	/**
	 * The available payment types to complete the order change.
	 *
	 * @todo
	 * Add this field to the API docs.
	 */
	available_payment_types?: PaymentType[] | null;
	/**
	 * The base price of the order for all flights and services booked,
	 * excluding taxes.
	 *
	 * @example
	 * "60.60"
	 */
	base_amount: string;
	/**
	 * The currency of the `base_amount`, as an ISO 4217 currency code. It
	 * will match your organisation's billing currency unless you’re using
	 * Duffel as an accredited IATA agent, in which case it will be in the
	 * currency provided by the airline (which will usually be based on the
	 * country where your IATA agency is registered).
	 *
	 * @example
	 * "GBP"
	 */
	base_currency: string;
	/**
	 * The airline's reference for the order, sometimes known as a "passenger
	 * name record" (PNR) or "record locator". Your customers can use this to
	 * check in and manage their booking on the airline's website. Usually,
	 * this is made up of six alphanumeric characters, but airlines can have
	 * their own formats (for example, easyJet's booking references are 7
	 * alphanumeric characters long and LATAM's references are made up of 13
	 * alphanumeric characters beginning with `LA`.)
	 *
	 * @example
	 * "RZPNX8"
	 */
	booking_reference: string;
	/**
	 * The ISO 8601 datetime at which the order was cancelled, if it has been
	 * cancelled.
	 *
	 * @example
	 * "2020-04-11T15:48:11.642Z"
	 */
	cancelled_at: string | null;
	/**
	 * The passenger-initiated changes for this Order.
	 */
	changes: OrderChanges;
	/**
	 * The conditions associated with this order, describing the kinds of
	 * modifications you can make to it and any penalties that will apply to
	 * those modifications. This information assumes the condition is applied
	 * to all of the slices and passengers associated with this order - for
	 * information at the slice level (e.g. "what happens if I just want to
	 * change the first slice?") refer to the `slices`. If a particular kind
	 * of modification is allowed, you may not always be able to take action
	 * through the Duffel API. In some cases, you may need to contact the
	 * Duffel support team or the airline directly.
	 */
	conditions: {
		change_before_departure: OfferCondition | null;
		refund_before_departure: OfferCondition | null;
	};
	/**
	 * Whether the Order is Self-Managed or Managed.
	 */
	content: "self_managed" | "managed";
	/**
	 * The ISO 8601 datetime at which the order was created.
	 *
	 * @example
	 * "2020-04-11T15:48:11.642Z"
	 *
	 */
	created_at: string;
	/**
	 *  The documents issued for this order.
	 */
	documents: OrderDocuments;
	/**
	 * Duffel's unique identifier for the order.
	 */
	id: string;
	/**
	 * Whether the order was created in live mode. This field will be set to
	 * `true` if the order was created in live mode, or `false` if it was
	 * created in test mode.
	 *
	 * @example
	 * false
	 */
	live_mode: boolean;
	/**
	 * Metadata contains a set of key-value pairs that you can attach to an
	 * object. It can be useful for storing additional information about the
	 * object, in a structured format. Duffel does not use this information.
	 * You should not store sensitive information in this field.
	 *
	 * @example
	 * {"customer_prefs":"window seat","payment_intent_id":"pit_00009htYpSCXrwaB9DnUm2"}
	 */
	metadata: Record<string, string>;
	/**
	 * The airline who owns the order.
	 */
	owner: Airline;
	/**
	 * The passengers who are travelling.
	 */
	passengers: OrderPassenger[];
	/**
	 * The payment status for this order.
	 */
	payment_status: OrderPaymentStatus;
	/**
	 * The services booked along with this order.
	 */
	services?: OrderService[];
	/**
	 * The slices that make up the itinerary of this order. One-way journeys
	 * can be expressed using one slice, whereas return trips will need two.
	 */
	slices: OrderSlice[];
	/**
	 * Airlines are always the source of truth for orders. The orders returned
	 * in the Duffel API are a view of those orders. This field is the ISO
	 * 8601 datetime at which the Order was last synced with the airline. If
	 * this datetime is in the last minute you can consider the order up to
	 * date.
	 *
	 * @example
	 * "2020-04-11T15:48:11Z"
	 */
	synced_at: string;
	/**
	 * The amount of tax payable on the order for all the flights booked.
	 *
	 * @example
	 * "30.20"
	 */
	tax_amount: string | null;
	/**
	 * The currency of the tax_amount, as an ISO 4217 currency code. It will
	 * match your organisation's billing currency unless you’re using Duffel
	 * as an accredited IATA agent, in which case it will be in the currency
	 * provided by the airline (which will usually be based on the country
	 * where your IATA agency is registered).
	 *
	 * @example
	 * "GBP"
	 */
	tax_currency: string | null;
	/**
	 * @todo
	 * Add this field to the API docs.
	 */
	ticket_by?: string | null;
	/**
	 * The total price of the order for all the flights and services booked,
	 * including taxes.
	 *
	 * @example
	 * "90.80"
	 */
	total_amount: string;
	/**
	 * The currency of the `totalAmount`, as an ISO 4217 currency code. It
	 * will match your organisation's billing currency unless you're using
	 * Duffel as an accredited IATA agent, in which case it will be in the
	 * currency provided by the airline (which will usually be based on the
	 * country where your IATA agency is registered).
	 *
	 * @example
	 * "GBP"
	 */
	total_currency: string;
}
export interface AdditionalBaggageSelectionCommonProps {
	/**
	 * List of all passengers that will be purchasing baggages
	 */
	passengers: LayoutSelectionPassenger[];
	/**
	 * What to do when the user presses the Confirm button
	 */
	onSubmit: (baggages: Baggage[]) => void;
	/**
	 * Already selected baggages to initialize the component with
	 */
	initialBaggageSelection?: Baggage[];
	/**
	 * Optional currency conversion to enable prices to be shown in an alternative currency
	 */
	currencyConversion?: CurrencyConversion;
}
export interface AdditionalBaggageSelectionOfferProps extends AdditionalBaggageSelectionCommonProps {
	/**
	 * The offer we are selecting additional baggages for
	 */
	offer: Offer;
	/**
	 * The order we are selecting additional baggages for
	 */
	order?: never;
	/**
	 * The available services that can be applied to this order
	 */
	availableServices?: never;
}
export interface AdditionalBaggageSelectionServicesProps extends AdditionalBaggageSelectionCommonProps {
	/**
	 * The offer we are selecting additional baggages for
	 */
	offer?: never;
	/**
	 * The order we are selecting additional baggages for
	 */
	order?: Order;
	/**
	 * The available services that can be applied to this order
	 */
	availableServices: OrderAvailableService[];
}
export declare type AdditionalBaggageSelectionProps = AdditionalBaggageSelectionOfferProps | AdditionalBaggageSelectionServicesProps;
export declare const AdditionalBaggageSelection: React.FC<AdditionalBaggageSelectionProps>;

export {};
